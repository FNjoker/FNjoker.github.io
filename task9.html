<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="DNS解析过程
解析顺序
1）浏览器缓存
　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；
2）系统缓存
　　当浏览器缓存中无域名对应IP（还没命中）浏览器会检查操作系统缓存中有没有对应的已解析过的结果。在wind">
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Hexo">
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo">

    <!--Type page-->
    
        <meta property="og:type" content="website">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>第九周任务</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="https://FNjoker.github.io">
                    Home
                </a>
            </li>
            
            
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        
            <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>
            <section class="main">
                
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/task9.html">
                第九周任务
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-09-29</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h1><p><img src="https://FNjoker.github.io/task9/4e4a20a4462309f72ac61ab6720e0cf3d6cad6ed.jpg" alt="4e4a20a4462309f72ac61ab6720e0cf3d6cad6ed"></p>
<p>解析顺序</p>
<p>1）浏览器缓存</p>
<p>　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p>
<p>2）系统缓存</p>
<p>　　当浏览器缓存中无域名对应IP（还没命中）浏览器会检查操作系统缓存中有没有对应的已解析过的结果。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。</p>
<p>​        注：这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。</p>
<p>3)本地DNS服务器</p>
<p>​        前两个过程无法解析时，就要用到我们网络配置中的”DNS服务器地址”了。操作系统会把这个域名发送给这个LDNS，也就是本地区的域名服务器。这个DNS通常都提供给用户本地互联网接入的一个DNS解析服务，例如用户是在学校接入互联网，那么用户的DNS服务器肯定在学校；如果用户是在小区接入互联网，那么用户的DNS就是再提供接入互联网的应用提供商，即电信或联通，也就是通常说的SPA，那么这个DNS通常也会在用户所在城市的某个角落，不会很远。Windows环境下通过命令行输入ipconfig，Linux环境下通过cat /etc/resolv.conf就可以查询配置的DNS服务器了。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，所以LDNS主要承担了域名的解析工作。</p>
<p>4）根域名服务器</p>
<p>　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；</p>
<p>5）顶级域名服务器（gTLD）</p>
<p>　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；</p>
<p>6）主域名服务器（Name Server）</p>
<p>　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；</p>
<p>7）本地域名服务器</p>
<p>​        主域名服务器查询到对应的IP地址后，会返回给本地域名服务器</p>
<p>8）保存结果至缓存</p>
<p>　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p>
<h1 id="web页面请求流程图"><a href="#web页面请求流程图" class="headerlink" title="web页面请求流程图"></a>web页面请求流程图</h1><p><img src="https://FNjoker.github.io/task9/Snipaste_2019-09-29_20-51-38.png" alt="Snipaste_2019-09-29_20-51-38"></p>
<h1 id="Nginx处理请求的11个阶段"><a href="#Nginx处理请求的11个阶段" class="headerlink" title="Nginx处理请求的11个阶段"></a>Nginx处理请求的11个阶段</h1><p>Nginx 处理请求的过程一共划分为 11 个阶段，按照执行顺序依次是 post-read、server-rewrite、find-config、rewrite、post-rewrite、preaccess、access、post-access、try-files、content 以及 log。</p>
<p>1、post-read</p>
<p>最先执行的 post-read 阶段在 Nginx 读取并解析完请求头（request headers）之后就立即开始运行</p>
<p>2、server-rewrite</p>
<p>location匹配前，修改uri的阶段，用于重定向，location块外的重写指令（多次执行） </p>
<p>3、find-config</p>
<p>uri寻找匹配的location块配置项（多次执行）</p>
<p>4、rewrite</p>
<p>rewrite: 找到location块后再修改uri，location级别的uri重写阶段（多次执行）</p>
<p>5、post-rewrite</p>
<p>这个阶段也像 find-config 阶段那样不接受 Nginx 模块注册处理程序，而是由 Nginx 核心完成 rewrite 阶段所要求的“内部跳转”操作（如果 rewrite 阶段有此要求的话）。例如：通过 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令把当前请求的 URI 无条件地改写为 /bar，同时发起一个“内部跳转”，最终跳进了 location /bar 中。这里比较有趣的地方是“内部跳转”的工作原理。“内部跳转”本质上其实就是把当前的请求处理阶段强行倒退到 find-config 阶段，以便重新进行请求 URI 与 location 配置块的配对。</p>
<p>6、preaccess</p>
<p>该阶段在 access 阶段之前执行，故名 preaccess.标准模块 <a href="http://wiki.nginx.org/HttpLimitReqModule" target="_blank" rel="noopener">ngx_limit_req</a> 和 <a href="http://wiki.nginx.org/HttpLimitZoneModule" target="_blank" rel="noopener">ngx_limit_zone</a> 就运行在此阶段，前者可以控制请求的访问频度，而后者可以限制访问的并发度。</p>
<p>7、access</p>
<p>判断是否允许这个请求进入</p>
<p>8、 post-access</p>
<p>向用户发送拒绝服务的错误码，用来响应上一阶段的拒绝</p>
<p>9、try-files</p>
<p>访问静态文件资源</p>
<p>10、content</p>
<p>内容生成阶段，该阶段产生响应，并发送到客户端</p>
<p>11、log</p>
<p>log阶段处理，比如记录访问量，统计平均响应时间，记录访问日志</p>
<h1 id="http首部字段"><a href="#http首部字段" class="headerlink" title="http首部字段"></a>http首部字段</h1><p>1.HTTP首部字段结构</p>
<p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首段字段名：字段值</span><br></pre></td></tr></table></figure>

<p>2.HTTP首部字段类型</p>
<p>（1）通用首部字段（General Header Fields）</p>
<p>请求报文和响应报文两方都会使用的首部</p>
<p>（2）请求首部字段（Request Header Fields）</p>
<p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</p>
<p>（3）响应首部字段（Response Header Fields）</p>
<p>从服务器端向客户端返回响应报文时使用的首部。补充了相应的附加内容，也会要求客户端附加额外的内容信息</p>
<p>（4）实体首部字段（Entity Header Fields）</p>
<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体相关的信息</p>
<p>3.HTTP/1.1 首部字段一览</p>
<p><img src="https://FNjoker.github.io/task9/Snipaste_2019-09-27_11-40-31.png" alt="Snipaste_2019-09-27_11-40-31"></p>
<p><img src="https://FNjoker.github.io/task9/Snipaste_2019-09-27_11-41-55.png" alt="Snipaste_2019-09-27_11-41-55"></p>
<p><img src="https://FNjoker.github.io/task9/Snipaste_2019-09-27_11-42-12.png" alt="Snipaste_2019-09-27_11-42-12"></p>
<p><img src="https://FNjoker.github.io/task9/Snipaste_2019-09-27_11-42-21.png" alt="Snipaste_2019-09-27_11-42-21"></p>
<h2 id="0x00-通用首部字段"><a href="#0x00-通用首部字段" class="headerlink" title="0x00 通用首部字段"></a>0x00 通用首部字段</h2><p>1.Cache-Control</p>
<p>通过指定首部字段Cache-Control指令，就能操作缓存的工作机制</p>
<p>Cache-Control指令一览</p>
<p><img src="https://FNjoker.github.io/task9/QQ%E5%9B%BE%E7%89%8720190927161157.jpg" alt="QQ图片20190927161157"></p>
<p><img src="https://FNjoker.github.io/task9/QQ%E5%9B%BE%E7%89%8720190927161137.jpg" alt="QQ图片20190927161137"></p>
<p>2.Connection</p>
<p>Connection首部字段具有两个作用：（1）控制不再转发给代理的首部字段（2）管理持久连接</p>
<p>控制代理不在转发的首部字段用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: 不再转发的首部字段名</span><br></pre></td></tr></table></figure>

<p>控制持久连接用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: close  //断开连接</span><br><span class="line">Connection: Keep-Alive  //持续连接</span><br></pre></td></tr></table></figure>

<p>3.Date</p>
<p>首部字段Date表命创建HTTP报文的日期和时间</p>
<p>日期时间格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT               //RFC1123</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03-Jul-12 04:40:59 GMT				//RFC850</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue Jul 03 04:40:59 2012					//与C标准库内的asctime()函数输出格式一致</span><br></pre></td></tr></table></figure>

<p>4.Pragma</p>
<p>Pragma是HTTP/1.1之前版本的历史遗留字段，仅作为与1.0版本的向后兼容而定义</p>
<p>规范定义格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure>

<p>5.Trailer</p>
<p>Trailer会事先说明在报文主体后记录了哪些首部字段。该字段可用在分块传输编码时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 03 Jul 2012 14:41:56 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">...</span><br><span class="line">Trailer: Expires</span><br><span class="line"></span><br><span class="line">...(报文主体)...</span><br><span class="line">0</span><br><span class="line">Expires: Tue, 28 Sep 2004 23:59:59 GMT</span><br></pre></td></tr></table></figure>

<p>6.Transfer-Encoding</p>
<p>Transfer-Encoding规定了传输报文主体时采用的编码方式，HTTP/1.1的传输编码方式仅对分块传输编码有效</p>
<p>7.Upgrade</p>
<p>首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通讯，其参数值可以用来指定一个完全不同的通信协议。</p>
<p>8.Via</p>
<p>使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径,Via还可避免请求回环的发生</p>
<p>9.Warning</p>
<p>HTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码][警告的主机:端口号] &quot;[警告内容]&quot;</span><br></pre></td></tr></table></figure>

<p>警告码如下：</p>
<table>
<thead>
<tr>
<th>警告码</th>
<th>警告内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>110</td>
<td>Response is stale（响应已过期）</td>
<td>代理返回已过期的资源</td>
</tr>
<tr>
<td>111</td>
<td>Revalidation failed（再验证失败）</td>
<td>代理再验证资源有效性时失败</td>
</tr>
<tr>
<td>112</td>
<td>Disconnection operation（断开连接操作）</td>
<td>代理与互联网连接被故意切断</td>
</tr>
<tr>
<td>113</td>
<td>Heuristic expiration（试探性过期）</td>
<td>响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td>
</tr>
<tr>
<td>199</td>
<td>Miscellaneous waring（杂项警告）</td>
<td>任意的警告内容</td>
</tr>
<tr>
<td>214</td>
<td>Transformation applied（使用了转换）</td>
<td>代理对内容编码或媒体类型等执行了某些处理时</td>
</tr>
<tr>
<td>299</td>
<td>Miscellaneous persistent warning（持久杂项警告）</td>
<td>任意的警告内容</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="0x01-请求首部字段"><a href="#0x01-请求首部字段" class="headerlink" title="0x01 请求首部字段"></a>0x01 请求首部字段</h2><p>1.Accept</p>
<p>Accept首部字段可通知服务器，用户代理能够 处理的媒体类型及媒体类型的优先级</p>
<p>媒体类型：<br>（1）文本文件</p>
<p>text/html,text/plain,text/css</p>
<p>application/xhtml+xml,application/xml</p>
<p>（2）图片文件</p>
<p>image/jpeg,image/gif,image/png…</p>
<p>（3）视频文件</p>
<p>video/mpeg,video/quicktime</p>
<p>（4）应用程序使用的二进制文件</p>
<p>application/octet-stream,application/zip</p>
<p>权重值q的范围是0-1（可精确到小数点后三位），且1为最大值。不指定权重q值时，默认权重q=1.0</p>
<p>2.Accept-Charset</p>
<p>Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集相对优先顺序。</p>
<p>3.Accept-Encoding</p>
<p>Accept-Encoding首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。</p>
<p>内容编码：</p>
<p>（1）gzip:有文件压缩程序gzip生成的编码格式（RFC1952）,采用Lempek-Ziv算法（LZ77）及32位循环冗余校验（CRC）</p>
<p>（2）compress</p>
<p>有UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法（LZW）</p>
<p>（3）deflate</p>
<p>组合使用zlib格式（RFC1950）及有deflate压缩算法（RFC1951）生成的编码格式</p>
<p>（4）identify</p>
<p>不执行压缩或不会变化的默认编码格式</p>
<p>4.Accept-Language</p>
<p>首部Accept-Language用来告知服务器用户代理能够处理的自然语言集，以及相对优先级</p>
<p>5.Authorization</p>
<p>首部字段Authorization是用来告知服务器，用户代理的认证信息</p>
<p>6.Expect</p>
<p>用来告知服务器期待出现的某种特定的行为，因服务器无法理解客户端的期望作出回应而发生错误时，会返回417 Expectation Failed.</p>
<p>7.From</p>
<p>首部字段From用来告知服务器使用用户代理的用户的电子邮件地址</p>
<p>8.Host</p>
<p>Host会告知服务器，请求的资源所处的互联网主机名和端口号，Host时HTTP/1.1规范内唯一一个必须被包含在请求内的首部字段</p>
<p>9.If-XXX</p>
<p>条件请求，只有判断指定条件为真时，才会执行请求</p>
<p>（1）If-Match</p>
<p>它会告知服务器匹配资源所用的实体标记（ETag）值。</p>
<p>（2）If-Modified-Since</p>
<p>它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望处理该请求，而在指定If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304 Not Modified响应</p>
<p>（3）If-None-Match</p>
<p>用于指定该字段值的实体标记（ETag）值与请求资源的ETag不一致时，它就告知服务器处理该请求</p>
<p>（4）If-Range</p>
<p>它告知服务器若指定的If-Range字段值和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源</p>
<p>（5）If-Unmodified-Since</p>
<p>它的作用是来告知服务器制定的请求资源只有在字段值内指定的时间之后，未更新的情况下，才能处理中请求</p>
<p>10.Max-Forwards</p>
<p>通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，会将Max-Forwards的值减1后重新赋值，当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应</p>
<p>灵活使用Max-Forwards字段，通过它的原理我们至少可以对目标服务器为终点的传输路径的通信状况有所把握。</p>
<p>11.Proxy-Authorization</p>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息</p>
<p>12.Range</p>
<p>用来告知服务器资源的指定范围</p>
<p>13.Referer</p>
<p>首部字段Referer会告知服务器请求的原始资源的URI</p>
<p>14.TE</p>
<p>首部字段TE会告知服务器客户端能够处理响应的传输编码方式及相对优先级</p>
<p>15.User-Agent</p>
<p>首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器</p>
<h2 id="0x02-响应首部字段"><a href="#0x02-响应首部字段" class="headerlink" title="0x02 响应首部字段"></a>0x02 响应首部字段</h2><p>1.Accept-Ranges</p>
<p>首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为bytes，反之则指定其为none</p>
<p>2.Age</p>
<p>首部字段Age能告知客户端源服务器在多久前创建了响应，单位为秒</p>
<p>3.ETag</p>
<p>首部字段ETag能告知客户端实体标识，当资源更新时ETag值也需要更新。生成ETag值时，并没有统一的算法规则，而仅仅是有服务器来分配。</p>
<p>弱ETag值只用于提示资源是否相同</p>
<p>强ETag值，不论实体发生多么细微的变化都会改变其值</p>
<p>4.Location</p>
<p>使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源</p>
<p>几乎所有的浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问</p>
<p>5.Proxy-Authenticate</p>
<p>首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端</p>
<p>6.Retry-After</p>
<p>首部字段Retry-After告知客户端应该在多久之后再次发送请求。可以是日期也可以是秒数</p>
<p>7.Server</p>
<p>首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息</p>
<p>8.Vary</p>
<p>首部字段Vary可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令</p>
<p>9.WWW-Authenticate</p>
<p>首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案和带参数提示的质询</p>
<h2 id="0x03-实体首部字段"><a href="#0x03-实体首部字段" class="headerlink" title="0x03 实体首部字段"></a>0x03 实体首部字段</h2><p>1.Allow</p>
<p>首部字段Allow用户通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回</p>
<p>2.Content-Encoding</p>
<p>首部字段Content-Encoding会告知客户端服务器对实体的主体部分选用的内容编码方式</p>
<p>3.Content-Language</p>
<p>首部字段Content-Language会告知客户端实体主体使用的自然语言</p>
<p>4.Content-Length</p>
<p>首部字段Content-Length表明了实体主体部分的大小（单位是字节）</p>
<p>5.Content-Location</p>
<p>首部字段Content-Location表示的是报文主体返回资源对应的URI</p>
<p>6.Content-MD5</p>
<p>首部字段Content-MD5是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认达到</p>
<p>7.Content-Type</p>
<p>首部字段Content-Type说明了实体主体内对象的媒体类型</p>
<p>8.Expires</p>
<p>首部字段Expires会将资源失效的日期告知客户端</p>
<p>9.Last-Modified</p>
<p>首部字段Last-Modified指明资源最终修改的时间</p>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><h2 id="0x00-状态码类别"><a href="#0x00-状态码类别" class="headerlink" title="0x00 状态码类别"></a>0x00 状态码类别</h2><table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1XX                       Information（信息状态码）</td>
<td>接收的请求正在处理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2XX                       Success（成功状态码）</td>
<td>请求正常处理完毕</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3XX                       Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4XX                       Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5XX                       Server Error（服务器错误状态码）</td>
<td>服务器处理请求错误</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="0x01-2XX"><a href="#0x01-2XX" class="headerlink" title="0x01 2XX"></a>0x01 2XX</h2><p>1.200 ok</p>
<p>表示从客户端发来的请求在服务器端被正常处理了</p>
<p>2.204 No Content</p>
<p>该状态码代表服务器接受的请求已成功处理，但在返回的响应报文中不包含实体的主体部分</p>
<p>3.206 Partial Content</p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</p>
<h2 id="0x02-3XX"><a href="#0x02-3XX" class="headerlink" title="0x02 3XX"></a>0x02 3XX</h2><p>1.301 Moved Permanently</p>
<p>永久性重定向。该状态码表示请求的资源已被分配了新的URI,以后应使用资源现在所指的URI</p>
<p>2.302 Found</p>
<p>临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户（本次）能使用新的URI访问</p>
<p>3.303 See Other</p>
<p>该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方式定向获取请求资源</p>
<p>4.304 Not Modified</p>
<p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因为发生请求为满足条件的情况后，直接返回304</p>
<p>5.307 Temporary Redirect</p>
<p>临时重定向，与302 Found 有着相同的含义</p>
<h2 id="0x03-4XX"><a href="#0x03-4XX" class="headerlink" title="0x03 4XX"></a>0x03 4XX</h2><p>1.400 Bad Request</p>
<p>该状态码表示请求报文中存在语法错误</p>
<p>2.401 Unauthorized</p>
<p>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。若之前已经进行过1次请求，则表示用户认证失败</p>
<p>3.403 Forbidden</p>
<p>该状态码表明对请求资源的访问被服务器拒绝了</p>
<p>4.404 Not Found</p>
<p>该状态码表示服务器上无法找到请求的资源，除此之外，也可以在服务器端拒绝请求且不想说明理由时使用</p>
<h2 id="0x04-5XX"><a href="#0x04-5XX" class="headerlink" title="0x04 5XX"></a>0x04 5XX</h2><p>1.500 Internal Server Error</p>
<p>该状态码表明服务器端在执行请求时发生了错误</p>
<p>2.503 Service Unavailable</p>
<p>该状态码表明服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求</p>
<p># </p>

    </div>

    

    

    <!-- Comments -->
    

</div>
            </section>
        
    </div>
</div>


</div>

<!-- Footer -->

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>